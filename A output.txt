import heapq
import time

# ---------------------------
# GRAPH (Weighted Road Map)
# ---------------------------

graph = {
    "A": {"B": 5, "C": 7},
    "B": {"D": 3},
    "C": {"D": 4},
    "D": {}
}

# ---------------------------
# HEURISTICS
# ---------------------------

# Heuristic 1: Always zero (Admissible)
def h_zero(node, goal):
    return 0

# Heuristic 2: Rough straight-line estimate
def h_straight(node, goal):
    estimates = {
        ("A", "D"): 6,
        ("B", "D"): 3,
        ("C", "D"): 4
    }
    return estimates.get((node, goal), 0)

# Heuristic 3: Informed / Strong estimate
def h_informed(node, goal):
    values = {
        ("A", "D"): 5,
        ("B", "D"): 2,
        ("C", "D"): 3
    }
    return values.get((node, goal), 0)

# ---------------------------
# A* SEARCH ALGORITHM
# ---------------------------

def a_star(graph, start, goal, heuristic):
    open_set = []
    heapq.heappush(open_set, (0, start))

    came_from = {}
    g_score = {node: float('inf') for node in graph}
    g_score[start] = 0

    f_score = {node: float('inf') for node in graph}
    f_score[start] = heuristic(start, goal)

    nodes_expanded = 0
    start_time = time.time()

    while open_set:
        _, current = heapq.heappop(open_set)

        if current == goal:
            end_time = time.time()
            return reconstruct_path(came_from, current), g_score[current], nodes_expanded, end_time - start_time

        nodes_expanded += 1

        for neighbor, weight in graph[current].items():
            tentative_g = g_score[current] + weight

            if tentative_g < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g
                f_score[neighbor] = tentative_g + heuristic(neighbor, goal)
                heapq.heappush(open_set, (f_score[neighbor], neighbor))

    end_time = time.time()
    return None, float('inf'), nodes_expanded, end_time - start_time

# ---------------------------
# RECONSTRUCT BEST PATH
# ---------------------------

def reconstruct_path(came_from, current):
    path = [current]
    while current in came_from:
        current = came_from[current]
        path.append(current)
    return path[::-1]

# ---------------------------
# RUN TESTS
# ---------------------------

start = "A"
goal = "D"

results = {}
results["Zero Heuristic"] = a_star(graph, start, goal, h_zero)
results["Straight-line"] = a_star(graph, start, goal, h_straight)
results["Informed"] = a_star(graph, start, goal, h_informed)

# ---------------------------
# DISPLAY RESULTS
# ---------------------------

for name, result in results.items():
    path, cost, nodes, runtime = result
    print(f"\n=== {name} ===")
    print("Path:", path)
    print("Cost:", cost)
    print("Nodes Expanded:", nodes)
    print("Runtime:", runtime)
