

continue
# weight depends on base random weight and diagonal vs straight
base = random.uniform(*weight_range)
if (dx != 0 and dy != 0):
# diagonal move cost roughly sqrt(2) times
weight = base * math.sqrt(2)
else:
weight = base
g.add_edge(u, v, weight)


# pick start and goal from free nodes far apart
if len(free_nodes) < 2:
raise RuntimeError("Not enough free nodes for start/goal selection")


# heuristic: choose endpoints with roughly maximal Euclidean separation
far_pair = (None, None, -1.0)
for i in range(200): # sample up to 200 random pairs
a = random.choice(free_nodes)
b = random.choice(free_nodes)
if a == b:
continue
d = g.distance(a, b)
if d > far_pair[2]:
far_pair = (a, b, d)


start, goal = far_pair[0], far_pair[1]
return g, start, goal


# ----------------------------- Experiment Harness -----------------------------


def run_experiment(graph: Graph, start: str, goal: str, heuristics: Dict[str, Callable[[str, str, Graph], float]]) -> List[Tuple[str, Optional[AStarResult]]]:
results = []
for name, hfunc in heuristics.items():
astar = AStar(graph, hfunc)
res = astar.search(start, goal)
results.append((name, res))
return results


# ----------------------------- Main / Example Runs -----------------------------


def main():
random.seed(42)


# generate a medium-sized grid
width, height = 30, 20
graph, start, goal = generate_weighted_grid(width, height, obstacle_prob=0.18, weight_range=(1.0, 4.0), diagonal=False)


# heuristics dictionary (wrap inadmissible to match signature)
heuristics = {
'h_zero (admissible, weak)': h_zero,
'h_euclidean (admissible, informed)': h_euclidean,
'h_inadmissible x1.5 (non-admissible)': lambda u,v,g: h_inadmissible(u,v,g,scale=1.5)
}


runs = run_experiment(graph, start, goal, heuristics)


# prepare CSV
csv_rows = []
print(f"Start: {start} Goal: {goal}")
for name, res in runs:
if res is None:
print(f"{name}: No path found")
csv_rows.append({'heuristic': name, 'runtime_s': None, 'nodes_expanded': None, 'path_cost': None, 'path_length': None})
continue


print(f"Heuristic: {name}")
print(f" runtime (s): {res.runtime:.6f}")
print(f" nodes expanded: {res.nodes_expanded}")
print(f" path cost: {res.cost:.4f}")
print(f" path length: {len(res.path)}")
csv_rows.append({'heuristic': name, 'runtime_s': res.runtime, 'nodes_expanded': res.nodes_expanded, 'path_cost': res.cost, 'path_length': len(res.path)})


csv_filename = 'astar_results.csv'
with open(csv_filename, 'w', newline='') as f:
writer = csv.DictWriter(f, fieldnames=['heuristic','runtime_s','nodes_expanded','path_cost','path_length'])
writer.writeheader()
for row in csv_rows:
writer.writerow(row)


print(f"Results written to {csv_filename}")


if __name__ == '__main__':
main()